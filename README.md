# Crudify란?

<br>

> Crudify는 손쉽게 API Server를 구현할 수 있는 headless CMS 서비스입니다.
<br>

```bash
$ npx create-crudify-app@latest my-project
```

<br>

터미널에 명령어를 입력하여 Express + MongoDB Server를 설치할 수 있습니다.<br>
<br>
API Server를 구축하기 어려운 사람들을 위해, Dashboard에서 서버를 관리할 수 있습니다.<br>
<br>
컬렉션을 생성해 데이터 **모델**을 정의할 수 있으며, **엔드포인트**를 연결해 CRUD 작업을 손쉽게 할 수 있습니다!
<br>
<br>

<details>
  <summary>
  
  ### Headless CMS
  
  </summary>
  
  <br>
  
  Headless CMS는, 말 그대로 창이 없는 CMS(Content Manage System)으로서,<br>

  웹 페이지를 렌더링해주는 것이 아니라, API 요청을 처리해 주는 API 서버를 구축해주는 서비스 입니다.<br>
  
</details>

<details>
  <summary>
  
  ### 동작 화면
  
  </summary>
  
  <br>
  
</details>

## 목차
- [Crudify란?](#Crudify란?)
  
- [고민했던 점](#고민했던-점)
  
  - [1. 서버를 어떻게 설치해줄 수 있을까?](#1-서버를-어떻게-설치해줄-수-있을까)
  
  - [2. 어떻게 대시보드로 서버를 조작할 수 있을까?](#2-어떻게-대시보드로-서버를-조작할-수-있을까)
  
  - [3. webpack bundling을 개선할 수는 없을까?](#3-webpack-bundling을-개선할-수는-없을까)

- [기술 스택](#기술-스택)

- [어려웠던 점 & 개선할 점](#어려웠던-점--개선할-점)

- [회고](#회고)
<br>

# 고민했던 점

## 1. 서버를 어떻게 설치해줄 수 있을까?

### npx 패키지와 npm 패키지에 대한 고민<br>
  
  npx는 일회성으로 패키지를 설치하는 데에 사용할 수 있는 패키지입니다.<br>
  <br>
  
  하지만 npx를 이용해서 패키지를 다운 받을 경우,<br>
  
  1. 서버를 설치하고<br>
  2. 서버를 구동하여 관리하는 과정이<br>
    
  하나의 과정으로 한 번에 이루어져야 했습니다.<br>
  <br>
  
  모든 과정이 한 번에 실행되기는 하지만, 파일 설치와 구동과 관리하는 부분은 별도의 기능으로 관리해야 한다고 생각했습니다.<br>
  
  그래서 단순 일회성으로 환경 파일을 설치해주는 부분은 npx로, 서버를 동작하고 제어하는 패키지는 npm으로 패키지를 분리해주었습니다.<br>
  <br>
  
  crudify 프로젝트의 구성은, 크게 npx 패키지(create-crudify-app)와 npm 패키지(crudify-service)로 나뉘게 됩니다.<br>
  
  우선 `create-crudify-app`을 실행하게 되면, 기본 설정 파일을 설치하게 됩니다.<br>
  
  이 후에 NodeJS의 child process 모듈을 사용, `npm install` 명령어를 실행해주어 npm 패키지를 설치하도록 하였습니다.<br>
<br>

### 디렉토리 구성에 대한 고민

  crudify는 특성 상, 단순히 서버 파일을 생성해주는 것이 아니라 대시보드를 통해서 이를 제어할 수 있어야 했습니다.<br>
  
  대시보드를 통해 서버를 가동하고, 종료가 되어 재시작이 될 수 있도록 서버를 제어해야 했습니다.<br>
  
  이를 구현하기 위해서 어떻게 파일 구조를 가져가면 좋을 지 고민하였습니다.<br>
  <br>
  
  꼭 필요한 부분을 제외하고, 대부분의 로직은 패키지 내부(node_modules)에서 처리할 수 있도록 작성하였습니다.<br>
  
  서비스 기능이 아닌 부분, 예를 들면 컬렉션에 대한 정보나 대시보드에서 설정되는 값들은 사용자 디렉토리에 저장하도록 설정했습니다.<br>
  <br>
  
  그래서 프로젝트를 설치하게 되면 몇 개의 간단한 디렉토리만 있어,<br>

  사용자가 프로젝트 파일을 확인 할 경우 서버 환경 정보를 용이하게 파악할 수 있도록 하였습니다.<br>
  
<br>

### 서버에 대한 파일을 어떤 식으로 작성할 지

  사용자 프로젝트에 설치되는 서버 환경 정보는 크게,<br>
  
  대시보드의 구성(model, api)과 프로젝트 설정 파일들로 구성되어 있습니다.<br>
  <br>
  
  대시보드가 구성되는 파일은, 예를 들어 model 디렉토리에는 각 model의 Schema가 어떻게 구성되는 지에 대한 정보가 담겨져 있습니다.<br>
  <br>

  model 파일에 대한 형식은 `package.json`이나 `webpack.config.js`와 같은 설정 파일들을 참고하여 작성하였습니다.<br>
  
  둘 다 설정 파일을 가져와 데이터를 구성해 특정 동작을 수행한다는 점이 파일의 컨셉과 비슷하다고 생각하였습니다.<br>

  webpack의 설정 파일처럼 javascript 파일로 생성할 경우, 함수의 형식으로 작성해 외부에서 데이터를 주입시킬 수 있습니다.<br>
  
  webpack에서 env 설정을 통해 webpack 설정을 다르게 처리해줄 수 있듯이요.<br>
  <br>

  반면 `.json`으로 작성되는 파일은 외부의 데이터를 참조하기 용이하지 않았습니다.<br>
  
  반면 데이터를 가져와서 처리하기가 비교적 간단하였습니다.<br>

  그래서 `.env`를 참조하는 등, 외부 데이터를 가져와 실행되는 파일은 `.js` 파일로,<br>
  
  데이터가 단순히 저장되는 파일은 `.json` 파일로 작성하였습니다.<br>
  <br>

  이외에도 사용자에게 `.env` 파일을 생성해주어야 했습니다.<br>
  
  `.env` 파일을 생성해줄 때 암호 데이터와 같은 값들은 새롭게 값이 생성되도록 해주고 싶었는데요.<br>

  그래서 `env.template` 파일을 통해 template를 정의, lodash의 `template` 메소드를 사용하여 `.env` 파일을 생성하는 방식을 사용하였습니다.<br>

<br>

## 2. 어떻게 대시보드로 서버를 조작할 수 있을까?

### monolith 방식에 대한 고민

  ‘서버에서 대시보드 웹 화면을 어떻게 띄워줄 수 있을 까’에 대해 고민하였습니다.<br>

  우선 가장 먼저 생각했던 방향은 monolith 방식으로, 서버의 라우터에서 웹 페이지를 동작시키는 방향이었습니다.<br>

  가장 단순하게 떠올릴 수 있는 방식이었지만, 한 가지 문제점이 있었습니다.<br> 
  <br>
  
  바로 서버의 동작과 대시보드의 동작이 연결되어있다는 점이었습니다.<br>

  대시보드에서 서버를 조작할 경우, 서버의 환경 정보 파일들이 수정되면서 서버가 재시작하도록 구현할 예정이었습니다.<br>

  하지만 그러면서 대시보드도 연결이 끊기게 되는 문제가 발생하게 됩니다.<br>

  대시보드는 계속 동작하면서 서버를 끄고 켤 수 있도록 제어하기 위해서는,<br>
  
  이 방법으로는 불가능하다고 판단했습니다.<br>
<br>

### 대시보드에서 작성된 내용이 사용자의 파일에 반영되도록

  대시보드에서 새로운 컬렉션을 생성해주고, model을 정의하고, api를 어떻게 연결할 수 있을 지 정의하게 됩니다.<br>

  대시보드에서 이러한 사항을 적용하고, 저장하기 버튼을 누르면 crudify의 api 서버로 요청을 보내도록 했습니다.<br>
  <br>

  api 서버에서 요청을 보내 처리하는 이유는, React에서 사용자의 파일에 직접적으로 접근할 수 없었기 때문입니다.<br>
  
  NodeJS의 fs 모듈을 사용하기 위해서는 서버로 요청을 보내, 서버에서 처리되도록 해야했습니다.<br>
  <br>

  api 서버를 구성할 때, 별도의 _dashboard 라우터를 연결하였습니다.<br>
  
  _dashboard 라우터에는 dashboard와의 데이터 연결에 필요한 엔드포인트가 정의되어 있습니다.<br>

  대시보드에서 _dashboard 라우터로 요청을 보내, 새로운 데이터를 생성하거나 수정할 수 있도록 합니다.<br>
  
  그런 다음 _dashboard에서 fs 모듈을 사용해 사용자 파일을 읽고 쓰게 됩니다.<br>

<br>

### 서버가 재시작되고, 대시보드에서 이를 감지하기까지

  프로젝트 디렉토리에 변경이 감지될 경우, Cluster에서 이를 감지해 서버가 종료되도록 하였습니다.<br>
  <br>

  Cluster는 main이 되는 primary와 worker로 나뉘게 되는데요,<br>
  
  worker 프로세스에서 API 서버를 실행하고 파일의 변경을 감지합니다.<br>
  <br>

  worker 프로세스에서 파일의 변경이 감지되는 경우, primary 프로세스로 메시지를 보내 서버를 종료시킵니다.<br>

  primary 프로세스에서는 서버가 종료 됨을 감지하게 되면, 다시 서버를 실행시키게 됩니다.<br>
  <br>

  서버는 실행 시마다 사용자의 서버 환경 파일들을 확인해 이를 반영하므로, 대시보드의 변경사항이 반영되게 됩니다.<br>
  <br>

  반면 대시보드는 이러한 과정의 진행 상황을 알 수 없습니다.<br>
  
  대시보드에서 modal을 통해 서버에 재시작을 발생시키는 시점을 알 수는 있지만,<br>
  
  이 후에는 별도로 이벤트를 수신할 수 없었습니다.<br>

  그래서 대시보드에서 서버에게 재시작 요청 시, 지속적으로 요청을 보내 연결을 체크하는 방식으로 재시작이 일어나게 됨을 감지하였습니다.<br>

<br>


## 3. webpack bundling을 개선할 수는 없을까?

  사용자에게 대시보드를 띄우면서 자체적으로 webpack으로 번들링해 web-server를 띄우게 되었습니다.<br>
  
  번들링 시, 기존에는 babel loader를 이용하였습니다.<br>
  <br>

  이 때 기존 5000 ~ 6000ms의 번들링 시간으로, 프로젝트가 설치되고 6초 정도의 딜레이가 발생하는 점을 확인하였습니다.<br>
  
  좀 더 번들링이 되는 시간을 줄여볼 수 없을까 생각하게 되었고, 아래와 같은 방법들을 도입하게 되었습니다.<br>
  <br>
  
  **`exclude: /node_modules/` 개선**<br>
  
  - 기존에는 webpack babel 설정에서 exclude를 통해, node_modules를 제외하였는데요.<br>
    
  - node_modules의 내부 코드들은 트랜스파일링할 필요가 없는 코드들이라, 따로 babel을 통해 트랜스파일링 할 필요가 없었습니다.<br>
    
  - 하지만 저는 프로젝트 구조 상, node_modules 내부에 프로젝트가 위치해있어 exclude 항목을 사용하지 않았는데요.<br>
    
  - 이에 따른 번들링 개선 방향으로, node_modules를 제외하고 현재 project를 include하도록 설정하였습니다.<br>
        
      ```jsx
      // before
      exclude: /node_modules/

      // after
      exclude: (modulePath) => (
        /node_modules/.test(modulePath)
        && !/node_modules\/crudify-service/.test(modulePath)
      )
      ```

  <br>  

  **esbuild-loader 사용**<br>

  - babel-loader 대신, esbuild-loader 사용해 javascript 파일을 번들링하도록 바꾸었습니다.<br>
    
  - es-build는 Go 언어를 통해 빠르게 번들링/트랜스파일링을 동작시켜주는 loader입니다.<br>
    
  - 기존 6000ms에서, 1200ms 가량으로 트랜스파일링 되는 시간이 단축되었습니다.<br>
    
  - 코드를 쓰면서 스쳐가는 많은 라이브러리를 관습적으로 사용하기 보다,<br>
  이것 저것 써보고 테스트해보면서 조금 더 잘 맞는 방법을 찾는 것이 중요하다는 것을 알게 되었습니다.
<br>

## 기술 스택

### React
- React를 이용하여, 대시보드를 SPA로 용이하게 제작하였습니다.
- css의 작성은 styled-components를 사용하였습니다.

### NodeJS
- fs, child_process, cluster와 같은 nodeJS의 내장 모듈을 활용하였습니다.

### Webpack
- 자체적으로 대시보드 서버를 번들링하여 웹 서버를 동작시키는데 사용하였습니다.
- 빌드 시간을 개선하기 위해서 loader는 babel이 아닌, esbuild를 사용하여 빌드 시간을 개선하였습니다.

### Express / MongoDB / Mongoose
- 사용자에게 서버를 만들어줄 때, Express와 MongoDB를 기반으로 제작하였습니다.
<br>

## 어려웠던 점 & 개선할 점

**파일 시스템(fs)과 CLI를 다루었던 부분**<br>

  저에게 NodeJS는 단순히 Express로 서버를 만들 때 이 외에는 써본 적이 없었는데요. <br>
  
  이번 프로젝트는 NodeJS의 다양한 모듈들을 학습할 수 있는 좋은 기회가 되었습니다. <br>
  
  파일 시스템 모듈의 같은 동작을 하는 메소드라도, 비동기 동기 방식과 Promise 방식 등 여러 방식을 사용할 수 있음을 깨닫게 되었습니다.<br>
  
  그리고 npx 패키지를 이용해 패키지를 설치해주는 기능을 넣으면서, CLI(Command Line Interface)를 제공하게 되었는데요. <br>
  
  처음에는 단순히 console.log()를 통해서만 표시해주면 된다고 생각했는데, loading 상태인 메시지나 강조하고 싶은 메시지 등<br>
  
  CLI를 더 다채롭게 표시해주어야 할 일이 많다는 것을 깨닫게 되었습니다.
  <br>
  <br>

**독특한 방식의 서버를 만들었던 부분**<br>

  이전에 서버를 만들 때는, router와 schema model을 직접 정의해서 만들었는데,<br>
  
  이번에는 특정 데이터를 가져와서 가공해서 서버를 만들어가는 부분이 신선하였습니다.<br>
  
  오히려 너무 단순하지 않을까 생각했던 서버임에도, 막상 구현하려니 데이터를 가공하고 적용하는 부분에서 까다로웠던 부분이 많았습니다.<br>
  
  그로 인해서 조금 더 다양한 기능, mongoose를 이용해서 활용할 수 있는 sub document, populate 등의 기능들을 시도해보고 싶었으나 해보지 못했는데,<br>
  나중에 기회가 된다면 제작해보고 싶습니다.
  <br>
  <br>

**프로젝트의 구조에 대한 고민**<br>

  일반적인 프론트엔드/백엔드 형식의 서비스가 아니라, 서버 파일을 설치해주고 웹을 띄워주는 다소 독특한 형태의 프로젝트이다보니,<br>
  
  파일 구조를 어떻게 효과적으로 정리할 수 있을 지 고민하게 되었습니다.<br>
  
  일반 웹 혹은 서버 프로젝트들은 참고할만한 레퍼런스들이 많은데 비해, 저는 디렉토리의 구조와 관련해서 적당히 참고받을 레퍼런스가 부족습니다.<br>
  
  우선은 단순히 폴더 내에서 기능을 한 파일에서 작성하다가, 성격이 다른 파일을 분리하고 같은 성격의 파일들을 한 디렉토리 내부로 묶어주는 등,<br>
  
  나름의 방법을 터득해 저만의 방법으로 프로젝트 구조를 정의하게 되었습니다.<br>
  
  처음에 효율적으로 구조를 설계해서 프로젝트를 진행해도 되지만, 이번처럼 프로젝트의 방향성이 확실하지 않은 경우는<br>
  
  일단 작성하면서 프로젝트에 대한 이해를 한 후에 구조를 잡아도 되겠다고 생각하였습니다.
  <br>
  <br>

**프로그래밍 기법 / 디자인 패턴의 도입**<br>

  프로젝트의 디렉토리 구조 뿐 아니라, 코드 내부적으로도 어떤 방식으로 효과적으로 코드를 작성할 수 있을 지 고민해보았는데요.<br>
  
  이 전에 과제들과 프로젝트들을 진행하면서 틈틈히 배운 객체지향/함수형 프로그래밍의 개념들과 디자인 패턴을 이번 프로젝트에 적용해보고 싶었습니다.<br>
  
  하지만 이런 프로젝트에 폭넓게 적용될 정도로 프로그래밍 개념, 디자인 패턴에 대한 이해가 깊지 않아, 하게 쓰게 되지는 않을까 생각하였습니다.<br>
  
  어떤 디자인 패턴, 혹은 프로그래밍 개념도 중요하지만,<br>
  
  이를 구현하려는 목적, 관심사의 분리와 재사용성이 높고 의존성이 낮은, 유지보수가 용이한 코드를 만드는 것이 더 중요하다고 판단하였습니다.<br>
  
  그래서 그런 점을 제 나름대로 구현해보려고 노력하였습니다.<br>
  
  파일 시스템 접근, 서버 접근 등 특정 목적성을 가진 service 로직은 service 파일에 분리하여 관리하고,<br>
  
  특정 목적을 가진 서비스 로직을 작성할 때 해당 서비스 클래스를 호출하도록 하였습니다.
  <br>
  <br>

**디자인 시스템**<br>

  React의 디렉토리 구조 및 컴포넌트의 구조는 어떻게 가져갈지에 대해서는 항상 고민이 많았던 부분입니다.<br>
  
  이전에는 컴포넌트를 최대한 분류를 해보려고 노력하였지만, 오히려 분류가 잘 되지않고 불편함을 낳는 경우가 많았습니다.<br>
  
  이번에는 오히려 모든 컴포넌트들을 한 곳에 두어 최대한 구분감있는 컴포넌트명을 만들자고 생각하였습니다.<br>
  
  그렇게되니 컴포넌트의 계층이 없어 가져오기는 편했지만, 너무 길고 읽기 힘들어 컴포넌트를 알아볼 수 없게 되는 일이 많아졌습니다.<br>
  
  다음에는 디자인 시스템, 그 중에서도 아토믹 디자인을 도입해서 디자인 시스템에 대해서 깊이 이해할 수 있었으면 좋겠다고 생각하였습니다.<br>
  
  아토믹 디자인은 컴포넌트를 계층별로 분리해 작은 요소 단위에서 큰 페이지 단위까지 계층을 매기는 점이 효율적이지 않을까 생각하였습니다.<br>
  
  <br> 
<br>

## 회고

처음 headless CMS라는 것을 알게 되고, 그 날 바로 구현해봐야겠다고 결심하게 되었습니다.

그로부터 2주가 조금 넘게 지난 지금까지 정말 많은 일들이 있었던 것 같습니다.
<br>
<br>

처음 headless CMS 서비스들을 보면서 신기함을 정말 많이 느꼈습니다.<br>

이게 어떻게 가능한 걸까? 하는 생각도 많았고, 어떻게 구현할 수 있을 지 밤새 찾아보았던 기억이 있습니다. 

그 과정에서 오픈 소스로 서비스되는 다른 서비스의 코드들도 찬찬히 뜯어보고, 라이브러리들도 하나하나 찾아가면서 고생을 많이 했습니다.

여러 오픈 소스들을 참고하여 보면서 프로젝트를 어떻게 진행해야할 지, 방향성과 같은 부분들을 많이 깨닫게 되어 도움이 많이 되었습니다.
<br>
<br>

반면에 복잡하고 방대한 오픈소스 프로젝트들의 코드들을 보면서 ‘내가 이 기능들을 다 할 수 있을까’하며 지레 겁을 먹지는 않았을까 생각하고는 합니다. 

프로젝트를 설계하는 초반에는, 조금 더 많은 기능을 생각하고 프로젝트에 도입하였는데요. <br>

곧 밀려드는 칸반에 압박에 휩싸이게 되면서 그때 그때 기능 구현에만 급급해 막막해 했던 적이 많았습니다.

중간에는 재미있는 시스템을 개발한다는 점이 조금도 즐겁지 않고, 기능을 구현해도 앞으로 남은 작업들이 많아 기쁘지도 않은 그런 순간이 찾아오게 되었습니다.
<br>
<br>

결국 생각했던 기능을 완전히 다 개발하지 못하고 프로젝트를 끝내게 되었는데요. <br>

주변에 프로젝트를 진행하는 다른 분들은 자신이 하는 것에 몰두하면서 재미있게 프로그래밍을 하는 것 같은데,<br>

저는 오히려 그러지 못해 아쉬움이 많이 남았습니다.
<br>
<br>

프로젝트를 즐기면서 했더라면 오히려 조금 지금보다 더 많은 기능들을 구현해놓지 않았을까? 생각하게 되었습니다.<br>

제가 프로젝트에 많은 욕심을 가지고 짧은 시간 내에 많은 기능을 구현해야겠다고 생각한 부분이,<br>

오히려 독이 되어 프로젝트를 제대로 진행하지 못했던게 아닌가하고요.

제가 할 수 있는 양과 실력을 객관적으로 바라보고 제 때 할 수있는 분량만큼 했더라면 좋지 않았을까? 하는 아쉬움이 남았습니다.<br>

그래도 제 프로젝트가 어느정도 완성되어 가는 모습을 보며, 뿌듯해했던 밤은 잊을 수가 없을 것 같습니다.
<br>
<br>
